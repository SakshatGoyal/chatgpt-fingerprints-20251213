# SVG Path NaN Error

## You (2025-04-06T02:17:02.158672+00:00)

‚úÖ Goal

We are building a Sankey-style node-pair parallel sets visualization, where:
	‚Ä¢	Each link connects two categories from adjacent dimensions (e.g. ‚ÄúValue Clash‚Äù ‚Üí ‚ÄúEvidence Frame‚Äù).
	‚Ä¢	Each link should be drawn as a curved SVG path using D3.
	‚Ä¢	The path thickness should reflect how many rows in the dataset pass through that exact node pair.

‚∏ª

‚ùó Problem

The browser is throwing the following runtime error:

Error: <path> attribute d: Expected number, "MNaN,NaNLNaN,NaN".

This means:
	‚Ä¢	The SVG path generator is receiving invalid coordinates.
	‚Ä¢	Specifically, either the x or y value passed to d3.line() is NaN (Not a Number).

‚∏ª

üß† Diagnosis Context
	‚Ä¢	Our code generates links correctly (confirmed by logs).
	‚Ä¢	Each link is then mapped to two positions: source and target, from the positions map.
	‚Ä¢	The debug log shows that at least one sample link has valid positions, so positions is generally being calculated.
	‚Ä¢	However, we are not filtering or protecting the rendering against links where:
	‚Ä¢	positions[...] might be undefined
	‚Ä¢	or x or y values are NaN (possibly from earlier logic errors or incomplete mapping)

‚∏ª

üß© What This Breaks

This causes:
	‚Ä¢	SVG paths to fail rendering entirely
	‚Ä¢	The entire visualization to silently disappear
	‚Ä¢	Errors to accumulate per broken link, making debugging noisy

‚∏ª

Here's the current code file

<script>
  import * as d3 from 'd3';

  export let data = [];

  let svg;
  let width = 1200;
  let height = 600;
  let selectedColumn = '';
  let selectedValue = '';

  // Add your target columns at the top

    const dimensions = [
    'Tension Axis',
    'Ambiguity Type',
    'Framing Move',
    'Friction Archetype',
    'Stabilizer',
    'False Clarity',
    'Org Implication'
  ];

  // Compute unique values per column

    let categoryValues = {};

  $: if (data.length) {
    categoryValues = {};
    for (const dim of dimensions) {
      categoryValues[dim] = Array.from(new Set(data.map(d => d[dim]))).sort();
    }
  }

  let positions = {};

$: if (data.length) {
  positions = {};
  for (let i = 0; i < dimensions.length; i++) {
    const dim = dimensions[i];
    const values = categoryValues[dim];
    const x = padding + i * axisSpacing;

    for (let j = 0; j < values.length; j++) {
      const y = 50 + j * 40 + 15; // vertical center of the block
      positions[`${dim}__${values[j]}`] = { x, y };
    }
  }
}


  // Create aggregated paths with counts
  $: links = [];

$: if (data.length) {
  const linkMap = new Map();

  for (const row of data) {
    for (let i = 0; i < dimensions.length - 1; i++) {
      const dimA = dimensions[i];
      const dimB = dimensions[i + 1];
      const valA = row[dimA];
      const valB = row[dimB];

      const key = `${dimA}__${valA}‚Üí${dimB}__${valB}`;
      if (!linkMap.has(key)) {
        linkMap.set(key, {
          source: { dim: dimA, value: valA },
          target: { dim: dimB, value: valB },
          count: 0
        });
      }
      linkMap.get(key).count += 1;
    }
  }
  links = Array.from(linkMap.values());
  console.log('Link count before cleanup:', linkMap.size);

  links = links.filter(link => {
    const sourcePos = positions[`${link.source.dim}__${link.source.value}`];
    const targetPos = positions[`${link.target.dim}__${link.target.value}`];
    return (
      sourcePos &&
      targetPos &&
      isFinite(sourcePos.x) &&
      isFinite(sourcePos.y) &&
      isFinite(targetPos.x) &&
      isFinite(targetPos.y)
    );
  });

  console.log('Link count after cleanup:', links.length);
  console.log('Sample link:', links[0]);
  console.log(
    'Has source pos:',
    positions[`${links[0].source.dim}__${links[0].source.value}`]
  );
  console.log(
    'Has target pos:',
    positions[`${links[0].target.dim}__${links[0].target.value}`]
  );
}

  // Calculate positions for each column and each category

  let padding = 100;
  let axisSpacing = (width - 2 * padding) / (dimensions.length - 1);

  // Add the drawing logic inside <svg>


</script>

<div style="margin-bottom: 1rem;">
  <label for="select-column">Select Column:</label>
  <select id="select-column" bind:value={selectedColumn}>
    <option value="">--</option>
    {#each dimensions as col}
      <option value={col}>{col}</option>
    {/each}
  </select>

  {#if selectedColumn}
    <label for="select-value" style="margin-left: 1rem;">Select Value:</label>
    <select id="select-value" bind:value={selectedValue}>
      <option value="">--</option>
      {#each categoryValues[selectedColumn] || [] as val}
        <option value={val}>{val}</option>
      {/each}
    </select>
  {/if}
</div>


<svg bind:this={svg} width={width} height={height}>
  {#each dimensions as dim, i}
    <g transform="translate({padding + i * axisSpacing}, 0)">
      <text x="0" y="20" font-weight="bold" text-anchor="middle">{dim}</text>
      {#each categoryValues[dim] || [] as value, j}
        <g transform="translate(0, {50 + j * 40})">
          <rect width="120" height="30" fill="#ccc" rx="4" ry="4"></rect>
          <text x="60" y="20" text-anchor="middle" font-size="12">{value}</text>
        </g>
      {/each}
    </g>
  {/each}

  {#each links as link}
  {#if positions[`${link.source.dim}__${link.source.value}`] && positions[`${link.target.dim}__${link.target.value}`]}
    <path
      d={
        d3.line().curve(d3.curveMonotoneX)([
          positions[`${link.source.dim}__${link.source.value}`],
          positions[`${link.target.dim}__${link.target.value}`]
        ])
      }
      fill="none"
      stroke={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 'hotpink'
          : '#bbb'
      }
      stroke-opacity={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 1
          : 0.15
      }
      stroke-width={Math.max(1, link.count)}
    />
  {/if}
{/each}
</svg>

## ChatGPT (2025-04-06T02:17:02.550584+00:00)

Great diagnosis so far ‚Äî you're close. The error `Error: <path> attribute d: Expected number, "MNaN,NaNLNaN,NaN"` means one or more of the `x` or `y` values passed to `d3.line()` is `NaN`.

Here‚Äôs what‚Äôs happening:

### ‚úÖ Root Cause
Your current SVG path generator is trying to pass `positions[...]` objects directly to `d3.line()`, like this:
```js
d3.line().curve(d3.curveMonotoneX)([
  positions[...],
  positions[...]
])
```

However, `d3.line()` expects an array of **[x, y] arrays**, not objects like `{ x, y }`. When D3 tries to access the coordinates, it gets `undefined`, causing `NaN`.

---

### ‚úÖ Fix

You need to **convert `{ x, y }` objects to `[x, y]` pairs** before feeding them into `d3.line()`.

---

### üõ† What to Change

#### Find this block (starts at this line):

```svelte
{#each links as link}
  {#if positions[`${link.source.dim}__${link.source.value}`] && positions[`${link.target.dim}__${link.target.value}`]}
    <path
      d={
        d3.line().curve(d3.curveMonotoneX)([
          positions[`${link.source.dim}__${link.source.value}`],
          positions[`${link.target.dim}__${link.target.value}`]
        ])
      }
```

#### Replace it with this (full updated block):

```svelte
{#each links as link}
  {#if positions[`${link.source.dim}__${link.source.value}`] && positions[`${link.target.dim}__${link.target.value}`]}
    <path
      d={
        d3.line().curve(d3.curveMonotoneX)([
          [
            positions[`${link.source.dim}__${link.source.value}`].x,
            positions[`${link.source.dim}__${link.source.value}`].y
          ],
          [
            positions[`${link.target.dim}__${link.target.value}`].x,
            positions[`${link.target.dim}__${link.target.value}`].y
          ]
        ])
      }
      fill="none"
      stroke={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 'hotpink'
          : '#bbb'
      }
      stroke-opacity={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 1
          : 0.15
      }
      stroke-width={Math.max(1, link.count)}
    />
  {/if}
{/each}
```

---

### ‚úÖ Result

This ensures:
- You convert `{ x, y }` to `[x, y]`
- The path generator receives valid numerical coordinates
- No more `NaN` path errors
- Visualization should render correctly üéâ

Let me know if you want to add curve smoothness or multi-segment paths later!

## You (2025-04-06T02:22:12.068851+00:00)

here's what the new code looks like, but i see a red line somewhere at the end as soon as i pasted your code

{#each links as link}
  {#if positions[`${link.source.dim}__${link.source.value}`] && positions[`${link.target.dim}__${link.target.value}`]}
    <path
      d={
        d3.line().curve(d3.curveMonotoneX)([
          [
            positions[`${link.source.dim}__${link.source.value}`].x,
            positions[`${link.source.dim}__${link.source.value}`].y
          ],
          [
            positions[`${link.target.dim}__${link.target.value}`].x,
            positions[`${link.target.dim}__${link.target.value}`].y
          ]
        ])
      }
      fill="none"
      stroke={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 'hotpink'
          : '#bbb'
      }
      stroke-opacity={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 1
          : 0.15
      }
      stroke-width={Math.max(1, link.count)}
    />
  {/if}
{/each}
      fill="none"
      stroke={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 'hotpink'
          : '#bbb'
      }
      stroke-opacity={
        selectedColumn && selectedValue &&
        (link.source.dim === selectedColumn && link.source.value === selectedValue) ||
        (link.target.dim === selectedColumn && link.target.value === selectedValue)
          ? 1
          : 0.15
      }
      stroke-width={Math.max(1, link.count)}
    />
  {/if}
{/each}
</svg>

## ChatGPT (2025-04-06T02:22:12.835414+00:00)

Ah yes ‚Äî it looks like you **accidentally duplicated the entire `<path>` block** after `{#each links as link}`. The red underline is likely due to this extra set of SVG attributes that are floating outside of any tag, breaking the Svelte template.

---

### ‚úÖ Fix

Delete everything **after the second `{/each}`**.

---

### Your code should end like this (exact last lines):

```svelte
      stroke-width={Math.max(1, link.count)}
    />
  {/if}
{/each}
</svg>
```

---

### ‚úÖ Explanation

- You only need **one copy** of the `<path>` block.
- The duplicated `fill="none"`...etc. outside any tag is causing a syntax error.

Once you remove that duplicate, your red underline will disappear and the app should run cleanly.

Let me know if you want to style the paths or animate them next!
